<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta name="generator" content="Doxygen 1.8.6"/>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <title>Vargas: vargas::Aligner&lt; num_reads, CellType, NativeT &gt; Class Template Reference</title>
    <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body>
<nav class="navbar navbar-default" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <a class="navbar-brand">Vargas 1.0</a>
        </div>
    </div>
</nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div class="content" id="content">
        <div class="container">
            <div class="row">
                <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                    <div style="margin-bottom: 15px;">
                        <!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>vargas</b></li><li class="navelem"><a class="el" href="classvargas_1_1Aligner.html">Aligner</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classvargas_1_1Aligner-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vargas::Aligner&lt; num_reads, CellType, NativeT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main SIMD SW <a class="el" href="classvargas_1_1Aligner.html" title="Main SIMD SW Aligner. ">Aligner</a>.  
 <a href="classvargas_1_1Aligner.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="alignment_8h_source.html">alignment.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending vectors from a previous node.  <a href="structvargas_1_1Aligner_1_1__seed.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaff42b643f981eeeae3213ed08710a6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#aaff42b643f981eeeae3213ed08710a6c">Aligner</a> (size_t max_node_len, int len)</td></tr>
<tr class="memdesc:aaff42b643f981eeeae3213ed08710a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor uses the following score values: <br/>
Match : 2 <br/>
Mismatch : -2 <br/>
Gap Open : 3 <br/>
Gap Extend : 1 <br/>
.  <a href="#aaff42b643f981eeeae3213ed08710a6c">More...</a><br/></td></tr>
<tr class="separator:aaff42b643f981eeeae3213ed08710a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9dc54b39b47f5000530197e7eb8346"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a5a9dc54b39b47f5000530197e7eb8346">Aligner</a> (size_t max_node_len, int len, uint8_t match, uint8_t mismatch, uint8_t open, uint8_t extend)</td></tr>
<tr class="memdesc:a5a9dc54b39b47f5000530197e7eb8346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set scoring parameters.  <a href="#a5a9dc54b39b47f5000530197e7eb8346">More...</a><br/></td></tr>
<tr class="separator:a5a9dc54b39b47f5000530197e7eb8346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1f0d25d87d731a27aeaed6a9c0bcc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a6c1f0d25d87d731a27aeaed6a9c0bcc3">set_scores</a> (int8_t match, int8_t mismatch, int8_t open, int8_t extend)</td></tr>
<tr class="separator:a6c1f0d25d87d731a27aeaed6a9c0bcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90f14e2abecc912653233868dcc799c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structvargas_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#af90f14e2abecc912653233868dcc799c">align</a> (const <a class="el" href="classvargas_1_1ReadBatch.html">ReadBatch</a>&lt; num_reads, CellType &gt; &amp;reads, const <a class="el" href="classvargas_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:af90f14e2abecc912653233868dcc799c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align a batch of reads to the given graph.  <a href="#af90f14e2abecc912653233868dcc799c">More...</a><br/></td></tr>
<tr class="separator:af90f14e2abecc912653233868dcc799c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98c1957d2318e18dfa120c04b4afefa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structvargas_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#ad98c1957d2318e18dfa120c04b4afefa">align</a> (const <a class="el" href="classvargas_1_1ReadBatch.html">ReadBatch</a>&lt; num_reads, CellType &gt; &amp;reads, <a class="el" href="classvargas_1_1Graph_1_1FilteringIter.html">Graph::FilteringIter</a> begin, <a class="el" href="classvargas_1_1Graph_1_1FilteringIter.html">Graph::FilteringIter</a> end)</td></tr>
<tr class="memdesc:ad98c1957d2318e18dfa120c04b4afefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align a batch of reads to a graph range, return a vector of alignments corresponding to the reads.  <a href="#ad98c1957d2318e18dfa120c04b4afefa">More...</a><br/></td></tr>
<tr class="separator:ad98c1957d2318e18dfa120c04b4afefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e08029e88392fa8fe7a4ad1343ae914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a8e08029e88392fa8fe7a4ad1343ae914">align_into</a> (<a class="el" href="classvargas_1_1ReadBatch.html">ReadBatch</a>&lt; num_reads, CellType &gt; reads, <a class="el" href="classvargas_1_1Graph_1_1FilteringIter.html">Graph::FilteringIter</a> begin, <a class="el" href="classvargas_1_1Graph_1_1FilteringIter.html">Graph::FilteringIter</a> end, std::vector&lt; <a class="el" href="structvargas_1_1Alignment.html">Alignment</a> &gt; &amp;aligns)</td></tr>
<tr class="memdesc:a8e08029e88392fa8fe7a4ad1343ae914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align a batch of reads to a graph range, return a vector of alignments corresponding to the reads.  <a href="#a8e08029e88392fa8fe7a4ad1343ae914">More...</a><br/></td></tr>
<tr class="separator:a8e08029e88392fa8fe7a4ad1343ae914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d568f4d49084e6b4795e88de85e9c0"><td class="memItemLeft" align="right" valign="top">CellType&lt; num_reads &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a45d568f4d49084e6b4795e88de85e9c0">_test_fill_node</a> (const <a class="el" href="classvargas_1_1Graph_1_1Node.html">Graph::Node</a> &amp;n, const <a class="el" href="classvargas_1_1ReadBatch.html">ReadBatch</a>&lt; num_reads, CellType &gt; &amp;reads, std::vector&lt; uint32_t &gt; &amp;pos)</td></tr>
<tr class="memdesc:a45d568f4d49084e6b4795e88de85e9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used for testing. returns the max score of the read alignment to the node.  <a href="#a45d568f4d49084e6b4795e88de85e9c0">More...</a><br/></td></tr>
<tr class="separator:a45d568f4d49084e6b4795e88de85e9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a556f92433b93714d9af85883ae02a7d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a556f92433b93714d9af85883ae02a7d6">_get_seed</a> (const std::vector&lt; uint32_t &gt; &amp;prev_ids, const std::unordered_map&lt; uint32_t, <a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a> &gt; &amp;seed_map, <a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a> *seed)</td></tr>
<tr class="memdesc:a556f92433b93714d9af85883ae02a7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best seed from all previous nodes.  <a href="#a556f92433b93714d9af85883ae02a7d6">More...</a><br/></td></tr>
<tr class="separator:a556f92433b93714d9af85883ae02a7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55de238c8fbc554bc1dc8c4966dfb183"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55de238c8fbc554bc1dc8c4966dfb183"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a55de238c8fbc554bc1dc8c4966dfb183">_dealloc</a> ()</td></tr>
<tr class="memdesc:a55de238c8fbc554bc1dc8c4966dfb183"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes allocated matrix filling vectors. <br/></td></tr>
<tr class="separator:a55de238c8fbc554bc1dc8c4966dfb183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46166f395397a1ee040e12ebc0e9118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#ae46166f395397a1ee040e12ebc0e9118">_alloc</a> ()</td></tr>
<tr class="memdesc:ae46166f395397a1ee040e12ebc0e9118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate S and D vectors. I is determined by template parameter.  <a href="#ae46166f395397a1ee040e12ebc0e9118">More...</a><br/></td></tr>
<tr class="separator:ae46166f395397a1ee040e12ebc0e9118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc21a0086e4af48513765c6a05619b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a4cc21a0086e4af48513765c6a05619b7">_fill_node</a> (const <a class="el" href="classvargas_1_1Graph_1_1Node.html">Graph::Node</a> &amp;n, const <a class="el" href="classvargas_1_1ReadBatch.html">ReadBatch</a>&lt; num_reads, CellType &gt; &amp;reads)</td></tr>
<tr class="memdesc:a4cc21a0086e4af48513765c6a05619b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes local alignment of the node, with no previous seed.  <a href="#a4cc21a0086e4af48513765c6a05619b7">More...</a><br/></td></tr>
<tr class="separator:a4cc21a0086e4af48513765c6a05619b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81fb77f08e81940547cbc6a4408997f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#aa81fb77f08e81940547cbc6a4408997f">_fill_node</a> (const <a class="el" href="classvargas_1_1Graph_1_1Node.html">Graph::Node</a> &amp;n, const <a class="el" href="classvargas_1_1ReadBatch.html">ReadBatch</a>&lt; num_reads, CellType &gt; &amp;reads, const <a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a> *s)</td></tr>
<tr class="memdesc:aa81fb77f08e81940547cbc6a4408997f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes local alignment to the node.  <a href="#aa81fb77f08e81940547cbc6a4408997f">More...</a><br/></td></tr>
<tr class="separator:aa81fb77f08e81940547cbc6a4408997f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e1f0ff869d864ad0c7ca668410de7c"><td class="memItemLeft" align="right" valign="top">__INLINE__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#ac0e1f0ff869d864ad0c7ca668410de7c">_fill_cell_rzcz</a> (const CellType&lt; num_reads &gt; &amp;read_base, const Base &amp;ref, const <a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a> *s)</td></tr>
<tr class="memdesc:ac0e1f0ff869d864ad0c7ca668410de7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the top left cell.  <a href="#ac0e1f0ff869d864ad0c7ca668410de7c">More...</a><br/></td></tr>
<tr class="separator:ac0e1f0ff869d864ad0c7ca668410de7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2808cc2e6092b59837193e96e2cd7faf"><td class="memItemLeft" align="right" valign="top">__INLINE__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a2808cc2e6092b59837193e96e2cd7faf">_fill_cell_rz</a> (const CellType&lt; num_reads &gt; &amp;read_base, const Base &amp;ref, const uint32_t &amp;col)</td></tr>
<tr class="memdesc:a2808cc2e6092b59837193e96e2cd7faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills cells when row is 0.  <a href="#a2808cc2e6092b59837193e96e2cd7faf">More...</a><br/></td></tr>
<tr class="separator:a2808cc2e6092b59837193e96e2cd7faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a80365e1c358bdc48ec605055d78a0"><td class="memItemLeft" align="right" valign="top">__INLINE__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a54a80365e1c358bdc48ec605055d78a0">_fill_cell_cz</a> (const CellType&lt; num_reads &gt; &amp;read_base, const Base &amp;ref, const uint32_t &amp;row, const <a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a> *s)</td></tr>
<tr class="memdesc:a54a80365e1c358bdc48ec605055d78a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills cells when col is 0.  <a href="#a54a80365e1c358bdc48ec605055d78a0">More...</a><br/></td></tr>
<tr class="separator:a54a80365e1c358bdc48ec605055d78a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317bb25ff1d54b7b337818dc225ad0e2"><td class="memItemLeft" align="right" valign="top">__INLINE__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a317bb25ff1d54b7b337818dc225ad0e2">_fill_cell</a> (const CellType&lt; num_reads &gt; &amp;read_base, const Base &amp;ref, const uint32_t &amp;row, const uint32_t &amp;col)</td></tr>
<tr class="memdesc:a317bb25ff1d54b7b337818dc225ad0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the current cell.  <a href="#a317bb25ff1d54b7b337818dc225ad0e2">More...</a><br/></td></tr>
<tr class="separator:a317bb25ff1d54b7b337818dc225ad0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfe36953e5922ff3e23046c5d88a729"><td class="memItemLeft" align="right" valign="top">__INLINE__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a2bfe36953e5922ff3e23046c5d88a729">_D</a> (const uint32_t &amp;col, const CellType&lt; num_reads &gt; &amp;Dp, const CellType&lt; num_reads &gt; &amp;Sp)</td></tr>
<tr class="memdesc:a2bfe36953e5922ff3e23046c5d88a729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Score if there is a deletion.  <a href="#a2bfe36953e5922ff3e23046c5d88a729">More...</a><br/></td></tr>
<tr class="separator:a2bfe36953e5922ff3e23046c5d88a729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341ab04359aa31d621901a9d102309e9"><td class="memItemLeft" align="right" valign="top">__INLINE__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a341ab04359aa31d621901a9d102309e9">_I</a> (const uint32_t &amp;row, const CellType&lt; num_reads &gt; &amp;Sc)</td></tr>
<tr class="memdesc:a341ab04359aa31d621901a9d102309e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Score if there is an insertion.  <a href="#a341ab04359aa31d621901a9d102309e9">More...</a><br/></td></tr>
<tr class="separator:a341ab04359aa31d621901a9d102309e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33f578e06f1a28aea15b63abb9c51f2"><td class="memItemLeft" align="right" valign="top">__INLINE__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#ac33f578e06f1a28aea15b63abb9c51f2">_M</a> (uint32_t col, const CellType&lt; num_reads &gt; &amp;read, const Base &amp;ref, const CellType&lt; num_reads &gt; &amp;Sp)</td></tr>
<tr class="memdesc:ac33f578e06f1a28aea15b63abb9c51f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Best score if there is a match/mismatch. Uses S_prev.  <a href="#ac33f578e06f1a28aea15b63abb9c51f2">More...</a><br/></td></tr>
<tr class="separator:ac33f578e06f1a28aea15b63abb9c51f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83206eb92ef7ad67bd4a8a029f33fe05"><td class="memItemLeft" align="right" valign="top">__INLINE__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a83206eb92ef7ad67bd4a8a029f33fe05">_fill_cell_finish</a> (const uint32_t &amp;row, const uint32_t &amp;col, const uint32_t &amp;node_origin, const std::vector&lt; <a class="el" href="structvargas_1_1Read.html">Read</a> &gt; &amp;reads)</td></tr>
<tr class="memdesc:a83206eb92ef7ad67bd4a8a029f33fe05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the max of D,I, and M vectors and stores the current best score/position Currently does not support non-deafault template args.  <a href="#a83206eb92ef7ad67bd4a8a029f33fe05">More...</a><br/></td></tr>
<tr class="separator:a83206eb92ef7ad67bd4a8a029f33fe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2d6d5815c6b31cfae0539345449771"><td class="memItemLeft" align="right" valign="top">__INLINE__ NativeT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a2f2d6d5815c6b31cfae0539345449771">extract</a> (uint8_t i, const CellType&lt; num_reads &gt; &amp;vec)</td></tr>
<tr class="memdesc:a2f2d6d5815c6b31cfae0539345449771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the i'th element from a vector. No range checking is done.  <a href="#a2f2d6d5815c6b31cfae0539345449771">More...</a><br/></td></tr>
<tr class="separator:a2f2d6d5815c6b31cfae0539345449771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c90ab3bbb833c1602f48315ef939895"><td class="memItemLeft" align="right" valign="top">__INLINE__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvargas_1_1Aligner.html#a8c90ab3bbb833c1602f48315ef939895">insert</a> (NativeT ins, uint8_t i, const CellType&lt; num_reads &gt; &amp;vec)</td></tr>
<tr class="memdesc:a8c90ab3bbb833c1602f48315ef939895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert into the i'th element from a vector. No range checking is done.  <a href="#a8c90ab3bbb833c1602f48315ef939895">More...</a><br/></td></tr>
<tr class="separator:a8c90ab3bbb833c1602f48315ef939895"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt;<br/>
class vargas::Aligner&lt; num_reads, CellType, NativeT &gt;</h3>

<p>Main SIMD SW <a class="el" href="classvargas_1_1Aligner.html" title="Main SIMD SW Aligner. ">Aligner</a>. </p>
<p>Aligns a read batch to a reference sequence. Note: "score" means something that is added, "penalty" refers to something that is subtracted. All scores/penalties are provided as positive integers. Most memory is allocated for the class so it can be reused during alignment. To reduce memory usage, the maximum node size can be reduced. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">num_reads</td><td>max number of reads. If a non-default T is used, this should be set to SIMDPP_FAST_T_SIZE where T corresponds to the width of T. For ex. Default T=simdpp::uint8 uses SIMDPP_FAST_INT8_SIZE </td></tr>
    <tr><td class="paramname">CellType</td><td>element type. Determines max score range. Default simdpp::uint8. </td></tr>
    <tr><td class="paramname">NativeT</td><td>Native version of CellType. Default uint8_t. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aaff42b643f981eeeae3213ed08710a6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::<a class="el" href="classvargas_1_1Aligner.html">Aligner</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_node_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor uses the following score values: <br/>
Match : 2 <br/>
Mismatch : -2 <br/>
Gap Open : 3 <br/>
Gap Extend : 1 <br/>
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_node_len</td><td>maximum node length </td></tr>
    <tr><td class="paramname">len</td><td>maximum read length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a9dc54b39b47f5000530197e7eb8346"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::<a class="el" href="classvargas_1_1Aligner.html">Aligner</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_node_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mismatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>extend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set scoring parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_node_len</td><td>max node length </td></tr>
    <tr><td class="paramname">len</td><td>max read length </td></tr>
    <tr><td class="paramname">match</td><td>match score </td></tr>
    <tr><td class="paramname">mismatch</td><td>mismatch penalty </td></tr>
    <tr><td class="paramname">open</td><td>gap open penalty </td></tr>
    <tr><td class="paramname">extend</td><td>gap extend penalty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae46166f395397a1ee040e12ebc0e9118"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::_alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate S and D vectors. I is determined by template parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>length of S and D vectors, i.e. node length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2bfe36953e5922ff3e23046c5d88a729"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE__ void <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::_D </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CellType&lt; num_reads &gt; &amp;&#160;</td>
          <td class="paramname"><em>Dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CellType&lt; num_reads &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Score if there is a deletion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>current column </td></tr>
    <tr><td class="paramname">Dp</td><td>Previous D value at current col. </td></tr>
    <tr><td class="paramname">Sp</td><td>Previous S value at current col. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a317bb25ff1d54b7b337818dc225ad0e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE__ void <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::_fill_cell </td>
          <td>(</td>
          <td class="paramtype">const CellType&lt; num_reads &gt; &amp;&#160;</td>
          <td class="paramname"><em>read_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Base &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the current cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_base</td><td><a class="el" href="classvargas_1_1ReadBatch.html" title="Container for a packaged batch of reads. ">ReadBatch</a> vector </td></tr>
    <tr><td class="paramname">ref</td><td>reference sequence base </td></tr>
    <tr><td class="paramname">row</td><td>current row in matrix </td></tr>
    <tr><td class="paramname">col</td><td>current column in matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54a80365e1c358bdc48ec605055d78a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE__ void <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::_fill_cell_cz </td>
          <td>(</td>
          <td class="paramtype">const CellType&lt; num_reads &gt; &amp;&#160;</td>
          <td class="paramname"><em>read_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Base &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a> *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills cells when col is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_base</td><td><a class="el" href="classvargas_1_1ReadBatch.html" title="Container for a packaged batch of reads. ">ReadBatch</a> vector </td></tr>
    <tr><td class="paramname">ref</td><td>reference sequence base </td></tr>
    <tr><td class="paramname">row</td><td>current row in matrix </td></tr>
    <tr><td class="paramname">seed</td><td>alignment seed from previous node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83206eb92ef7ad67bd4a8a029f33fe05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE__ void <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::_fill_cell_finish </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>node_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvargas_1_1Read.html">Read</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>reads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes the max of D,I, and M vectors and stores the current best score/position Currently does not support non-deafault template args. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>current row </td></tr>
    <tr><td class="paramname">col</td><td>current column </td></tr>
    <tr><td class="paramname">n</td><td>Current node, used to get absolute alignment position </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2808cc2e6092b59837193e96e2cd7faf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE__ void <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::_fill_cell_rz </td>
          <td>(</td>
          <td class="paramtype">const CellType&lt; num_reads &gt; &amp;&#160;</td>
          <td class="paramname"><em>read_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Base &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills cells when row is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_base</td><td><a class="el" href="classvargas_1_1ReadBatch.html" title="Container for a packaged batch of reads. ">ReadBatch</a> vector </td></tr>
    <tr><td class="paramname">ref</td><td>reference sequence base </td></tr>
    <tr><td class="paramname">col</td><td>current column in matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0e1f0ff869d864ad0c7ca668410de7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE__ void <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::_fill_cell_rzcz </td>
          <td>(</td>
          <td class="paramtype">const CellType&lt; num_reads &gt; &amp;&#160;</td>
          <td class="paramname"><em>read_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Base &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a> *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the top left cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_base</td><td><a class="el" href="classvargas_1_1ReadBatch.html" title="Container for a packaged batch of reads. ">ReadBatch</a> vector </td></tr>
    <tr><td class="paramname">ref</td><td>reference sequence base </td></tr>
    <tr><td class="paramname">seed</td><td>alignment seed from previous node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4cc21a0086e4af48513765c6a05619b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a> <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::_fill_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvargas_1_1Graph_1_1Node.html">Graph::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvargas_1_1ReadBatch.html">ReadBatch</a>&lt; num_reads, CellType &gt; &amp;&#160;</td>
          <td class="paramname"><em>reads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes local alignment of the node, with no previous seed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Node to align to </td></tr>
    <tr><td class="paramname">reads</td><td><a class="el" href="classvargas_1_1ReadBatch.html" title="Container for a packaged batch of reads. ">ReadBatch</a> to align </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa81fb77f08e81940547cbc6a4408997f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a> <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::_fill_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvargas_1_1Graph_1_1Node.html">Graph::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvargas_1_1ReadBatch.html">ReadBatch</a>&lt; num_reads, CellType &gt; &amp;&#160;</td>
          <td class="paramname"><em>reads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a> *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes local alignment to the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Node to align to </td></tr>
    <tr><td class="paramname">reads</td><td><a class="el" href="classvargas_1_1ReadBatch.html" title="Container for a packaged batch of reads. ">ReadBatch</a> to align </td></tr>
    <tr><td class="paramname">seeds</td><td>seeds from previous nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a556f92433b93714d9af85883ae02a7d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::_get_seed </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>prev_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; uint32_t, <a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seed_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvargas_1_1Aligner_1_1__seed.html">_seed</a> *&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the best seed from all previous nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev_ids</td><td>All nodes preceding current node </td></tr>
    <tr><td class="paramname">seed_map</td><td>ID-&gt;seed map for all previous nodes </td></tr>
    <tr><td class="paramname"><a class="el" href="structvargas_1_1Aligner_1_1__seed.html" title="Ending vectors from a previous node. ">_seed</a></td><td>best seed to populate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a341ab04359aa31d621901a9d102309e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE__ void <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::_I </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CellType&lt; num_reads &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Score if there is an insertion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>current row </td></tr>
    <tr><td class="paramname">Sc</td><td>Previous S value (cell to the left) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac33f578e06f1a28aea15b63abb9c51f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE__ void <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::_M </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CellType&lt; num_reads &gt; &amp;&#160;</td>
          <td class="paramname"><em>read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Base &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CellType&lt; num_reads &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Best score if there is a match/mismatch. Uses S_prev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>current column </td></tr>
    <tr><td class="paramname">read</td><td>read base vector </td></tr>
    <tr><td class="paramname">ref</td><td>reference sequence base </td></tr>
    <tr><td class="paramname">Sp</td><td>Previous S val at col-1 (upper left cell) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45d568f4d49084e6b4795e88de85e9c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CellType&lt;num_reads&gt; <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::_test_fill_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvargas_1_1Graph_1_1Node.html">Graph::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvargas_1_1ReadBatch.html">ReadBatch</a>&lt; num_reads, CellType &gt; &amp;&#160;</td>
          <td class="paramname"><em>reads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only used for testing. returns the max score of the read alignment to the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Node to align to </td></tr>
    <tr><td class="paramname">reads</td><td><a class="el" href="classvargas_1_1ReadBatch.html" title="Container for a packaged batch of reads. ">ReadBatch</a> to align </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af90f14e2abecc912653233868dcc799c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structvargas_1_1Alignment.html">Alignment</a>&gt; <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvargas_1_1ReadBatch.html">ReadBatch</a>&lt; num_reads, CellType &gt; &amp;&#160;</td>
          <td class="paramname"><em>reads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvargas_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Align a batch of reads to the given graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reads</td><td>read batch </td></tr>
    <tr><td class="paramname">g</td><td><a class="el" href="classvargas_1_1Graph.html" title="Represents a Graph of the genome. ">Graph</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of <a class="el" href="structvargas_1_1Alignment.html">Alignment</a> structures. </dd></dl>

</div>
</div>
<a class="anchor" id="ad98c1957d2318e18dfa120c04b4afefa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structvargas_1_1Alignment.html">Alignment</a>&gt; <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvargas_1_1ReadBatch.html">ReadBatch</a>&lt; num_reads, CellType &gt; &amp;&#160;</td>
          <td class="paramname"><em>reads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvargas_1_1Graph_1_1FilteringIter.html">Graph::FilteringIter</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvargas_1_1Graph_1_1FilteringIter.html">Graph::FilteringIter</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Align a batch of reads to a graph range, return a vector of alignments corresponding to the reads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reads</td><td><a class="el" href="classvargas_1_1ReadBatch.html" title="Container for a packaged batch of reads. ">ReadBatch</a> to align </td></tr>
    <tr><td class="paramname">begin</td><td>iterator to beginning of graph </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of <a class="el" href="structvargas_1_1Alignment.html">Alignment</a> structures </dd></dl>

</div>
</div>
<a class="anchor" id="a8e08029e88392fa8fe7a4ad1343ae914"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::align_into </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvargas_1_1ReadBatch.html">ReadBatch</a>&lt; num_reads, CellType &gt;&#160;</td>
          <td class="paramname"><em>reads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvargas_1_1Graph_1_1FilteringIter.html">Graph::FilteringIter</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvargas_1_1Graph_1_1FilteringIter.html">Graph::FilteringIter</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structvargas_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aligns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Align a batch of reads to a graph range, return a vector of alignments corresponding to the reads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reads</td><td><a class="el" href="classvargas_1_1ReadBatch.html" title="Container for a packaged batch of reads. ">ReadBatch</a> to align </td></tr>
    <tr><td class="paramname">begin</td><td>iterator to beginning of graph </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of graph </td></tr>
    <tr><td class="paramname">aligns</td><td>vector of <a class="el" href="structvargas_1_1Alignment.html">Alignment</a> structures to populate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f2d6d5815c6b31cfae0539345449771"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE__ NativeT <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CellType&lt; num_reads &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the i'th element from a vector. No range checking is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>index of element </td></tr>
    <tr><td class="paramname">vec</td><td>vector to extract from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c90ab3bbb833c1602f48315ef939895"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE__ void <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">NativeT&#160;</td>
          <td class="paramname"><em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CellType&lt; num_reads &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert into the i'th element from a vector. No range checking is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ins</td><td>element to insert </td></tr>
    <tr><td class="paramname">i</td><td>index of element </td></tr>
    <tr><td class="paramname">vec</td><td>vector to insert in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c1f0d25d87d731a27aeaed6a9c0bcc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int num_reads = SIMDPP_FAST_INT8_SIZE, template&lt; unsigned int, typename=void &gt; class CellType = simdpp::uint8, typename NativeT = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvargas_1_1Aligner.html">vargas::Aligner</a>&lt; num_reads, CellType, NativeT &gt;::set_scores </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>mismatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>extend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the scoring scheme used for the alignments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">match</td><td>match score </td></tr>
    <tr><td class="paramname">mismatch</td><td>mismatch score </td></tr>
    <tr><td class="paramname">open</td><td>gap open penalty </td></tr>
    <tr><td class="paramname">extend</td><td>gap extend penalty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="alignment_8h_source.html">alignment.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/>
<address class="footer">
    <small>
        Generated on Sun Jun 26 2016 14:53:48 for Vargas by &#160;<a href="http://www.doxygen.org/index.html">
        <img class="footer" src="doxygen.png" alt="doxygen"/>
    </a> 1.8.6
    </small>
</address>
</body>
</html>
